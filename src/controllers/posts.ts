import type { NextApiRequest, NextApiResponse } from "next";
import { v4 as uuidv4 } from "uuid";

import { PostPriority } from "@/const";
import { createAnonToken, setAuthToken, getAuthToken } from "@/utils";
import { verifyToken } from "@/lib/jwt";
import { admin } from "@/lib/firebase-admin";
import type {
  Post,
  PostPatchRequest,
  PostCreateRequest,
  AuthToken,
  UserAnalytic,
} from "@/types";

export const postsHandler = {
  handle: (req: NextApiRequest, res: NextApiResponse) => {
    switch (req.method) {
      case "GET":
        handleGetRequest(req, res);
        break;
      case "POST":
        handlePostRequest(req, res);
        break;
      case "DELETE":
        handlePostDeleteRequest(req, res);
        break;
      case "PATCH":
        handlePatchRequest(req, res);
        break;
      default:
        res.status(405).end(); // Method Not Allowed
        break;
    }
  },
};

const handleGetRequest = async (req: NextApiRequest, res: NextApiResponse) => {
  // add anon cookie
  let token = getAuthToken(req);
  if (!getAuthToken(req)) {
    token = createAnonToken({ is_editor: false });

    // set cookie
    setAuthToken(res, token);
  }

  const db = admin.firestore();
  // record analytics in firestore
  const userId = verifyToken<AuthToken>(getAuthToken(req)!).user_id;
  const analyticsDoc = db.collection("analytics").doc("views");

  const cursor: string | null = req.query.cursor?.toString() || null;
  const limit = 20;

  const isEditor = verifyToken<AuthToken>(token!)?.is_editor ?? false;
  let query = db
    .collection("posts")
    .where("deleted_at", "==", null)
    .where("is_draft", "==", false)
    .orderBy("priority", "desc")
    .orderBy("created_at", "desc")
    .limit(limit);

  if (!isEditor) {
    query = query.where("is_private", "==", false);
  }

  if (cursor) {
    const cursorDoc = await db.collection("posts").doc(cursor).get();

    if (!cursorDoc.exists) {
      res.status(404).end(); // Not Found
      return;
    }

    query = query.startAfter(cursorDoc);
  }

  const analytics: UserAnalytic = {
    user_id: userId,
    views: admin.firestore.FieldValue.increment(1),
    ua: req.headers["user-agent"],
    ip: req.headers["x-forwarded-for"] || req.socket.remoteAddress,
    is_editor: isEditor,

    created_at: new Date().getTime(),
    updated_at: new Date().getTime(),
    deleted_at: null,
  } as UserAnalytic;

  const [querySnapshot, _] = await Promise.all([
    query.get(),
    analyticsDoc.set(
      {
        [userId]: analytics,
      },
      { merge: true }
    ),
  ]);

  const posts: Post[] = [];
  querySnapshot.forEach((doc) => {
    posts.push({
      post_id: doc.id,
      ...doc.data(),
    } as Post);
  });

  res.status(200).json({
    data: posts,
    has_more: posts.length === limit,
    cursor: posts.length > 0 ? posts[posts.length - 1].post_id : null,
  });
};

const handlePostRequest = async (req: NextApiRequest, res: NextApiResponse) => {
  // if no auth, check password in body
  if (!getAuthToken(req)) {
    const { password } = req.body as PostCreateRequest;

    if (password !== process.env.POST_PASSWORD) {
      res.status(401).send({
        error: "password is incorrect",
      }); // Unauthorized
      return;
    }

    // create auth token
    const token = createAnonToken({ is_editor: true });

    // set cookie
    setAuthToken(res, token);
  }

  // get authToken from cookie
  try {
    const authToken = verifyToken<AuthToken>(getAuthToken(req)!);

    if (!authToken?.is_editor) {
      if (req.body.password !== process.env.POST_PASSWORD) {
        res.status(401).send({
          error: "password is incorrect",
        }); // Unauthorized
        return;
      }

      // create auth token
      const token = createAnonToken({ is_editor: true });

      // set cookie
      setAuthToken(res, token);
    }
  } catch (err) {
    res.status(401).send({
      error: "token is invalid",
    }); // Unauthorized
    return;
  }

  const { content, is_draft, is_private } = req.body as PostCreateRequest;
  if ((content ?? "").length == 0) {
    res.status(400).send({
      error: "content is required",
    });
    return;
  }

  const postId = uuidv4();

  // id is autogenerated by Firestore
  const post: Post = {
    content,
    is_draft,
    is_private,
    priority: PostPriority.Default,
    post_id: postId,
    is_legacy: false,

    created_at: new Date().getTime(),
    updated_at: new Date().getTime(),
    deleted_at: null,
  };

  const db = admin.firestore();
  await db.collection("posts").doc(postId).set(post);

  res.status(201).json({ data: post });
};

const handlePostDeleteRequest = async (req: NextApiRequest, res: NextApiResponse) => {
  // get authToken from cookie
  const authToken = verifyToken(getAuthToken(req)!) as AuthToken;

  if (!authToken ?? !authToken.is_editor) {
    res.status(401).send({
      error: "token is invalid",
    }); // Unauthorized
    return;
  }

  const postId = req.body.post_id;
  if (!postId) {
    res.status(400).send({
      error: "postId is required",
    });
    return;
  }

  const db = admin.firestore();

  const postRef = db.collection("posts").doc(postId);
  const postDoc = await postRef.get();

  if (!postDoc.exists) {
    res.status(404).end(); // Not Found
    return;
  }

  const post = postDoc.data() as Post;
  if (post.deleted_at) {
    res.status(400).send({
      error: "post is already deleted",
    });
    return;
  }

  await postRef.update({
    deleted_at: new Date().getTime(),
  });

  res.status(200).json({ data: post });
};

const handlePatchRequest = async (req: NextApiRequest, res: NextApiResponse) => {
  // get authToken from cookie
  const authToken = verifyToken(getAuthToken(req)!) as AuthToken;

  if (!authToken ?? !authToken.is_editor) {
    res.status(401).send({
      error: "token is invalid",
    }); // Unauthorized
    return;
  }

  const postId = req.body.post_id;
  if (!postId) {
    res.status(400).send({
      error: "postId is required",
    });
    return;
  }

  const db = admin.firestore();

  const postRef = db.collection("posts").doc(postId);
  const postDoc = await postRef.get();

  if (!postDoc.exists) {
    res.status(404).end(); // Not Found
    return;
  }

  const post = postDoc.data() as Post;

  const { content, is_draft, is_private, priority } = req.body as PostPatchRequest;
  if (priority && priority != PostPriority.Pinned && priority != PostPriority.Default) {
    res.status(400).send({
      error: "priority must be 0 or 1",
    });
    return;
  }

  // only update fields that are passed in
  const updatedFields: Partial<Post> = {};
  if (content) {
    updatedFields.content = content;
  }
  if (is_draft !== undefined) {
    updatedFields.is_draft = is_draft;
  }
  if (is_private !== undefined) {
    updatedFields.is_private = is_private;
  }
  if (priority !== undefined) {
    updatedFields.priority = priority;
  }

  const updateData = {
    ...updatedFields,
    updated_at: new Date().getTime(),
  };

  await postRef.update(updateData);

  res.status(200).json({
    data: {
      ...post,
      ...updateData,
    },
  });
};
